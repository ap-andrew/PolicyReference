<p>[toc]</p>
<p>APIs are at their best when they are combined to create composite services that bundle representations of resources from multiple services and API providers. One way to create composite services on the API Platform to configure a ServiceCallout policy within a request or response flow.</p>
<p>A typical use case involves a service callout from a response flow to a third-party API (external service). The response from the &nbsp;third-party API is parsed and inserted in the response message to the requesting app. In this way, the data returned from the backend service is enriched with the data obtained from the third-party API, providing the end users of the app with data &nbsp;'mashed up' from multiple services. For example, you can configure a service callout policy to calls APIs that deliver relevant geolocation data, customer reviews, &nbsp;items from a partnerâ€™s retail catalog, and so on.</p>
<p>(An alternative approach to calling backend services or third-party APIs from the API Platform is writing JavaScript applications using [node:3976]. For coding sample and walkthrough, see [node:3975].</p>
<h2><a class="jumplink" name="comp"></a>Policy composition</h2>
<p><em>Policy composition</em> is an important concept to understand when configuring the service callout policy. Policy composition is the definition of a sequence of policies that work together to perform custom processing. Service callout policy is usually used with two other policy types, Assign Message and Extract Variables policy. The Assign Message policy is used to populate the request message sent to the remote service that is the target of the Service Callout policy. The Extract Variables policy is used to extract specific content within the response message received from the target of the Service Callout policy.&nbsp;</p>
<p>The typical Service Callout policy composition involves:</p>
<ol>
	<li>Assign Message Policy: Creates a request message, populates HTTP headers, query parameters, sets the HTTP verb, etc.</li>
	<li>Service Callout Policy: References a message created by the Assign Message policy, defines a target URL for the external call, and defines a name for the response object that the target service returns.</li>
	<li>Extract Variables Policy: Typically defines a JSONPath or XPath expression that parses the message generated by the preceding Service Callout policy. The policy then sets variables containing the values parsed from the Service Callout response.</li>
</ol>
<p>For a sample policy composition that performs a service callout, see the <a href="https://github.com/apigee/api-platform-samples">API Platform samples</a> on Github.</p>
<p>For more information, see [node:228] and [node:227].</p>
<h2><a class="jumplink" name="configure_policy"></a>Configuring the Service Callout policy</h2>
<p>You can configure the Service Callout policy in one of two ways:</p>
<ul>
	<li><strong>Using the policy editor:</strong> Drag and drop the Service Callout policy onto the message flow in the policy editor and then configure the elements of the policy using the Map view in the policy editor. For more information, see [node:219]. You can also configure the elements using the Code view in the policy editor that allows you to edit the XML fields directly instead of editing them offline. For more information on Code view, see [node:436].
		<p>[[{"type":"media","view_mode":"media_original","fid":"456","attributes":{"alt":"","class":"media-image","height":"295","style":"width: 330px; height: 227px; border-width: 1px; border-style: solid; margin: 10px;","typeof":"foaf:Image","width":"428"}}]]</p>
	</li>
	<li><strong>Using your favorite editor or IDE:</strong> Export your API proxy. Unzip and open/edit the API proxy configuration files offline in your favorite text editor or IDE. For more information, see [node:220].</li>
</ul>
<p>Configure the Service Callout policy using the following elements.</p>
<table border="0" cellpadding="1" cellspacing="1" class="table" style="width: 690px;">
	<thead>
		<tr>
			<th colspan="1" rowspan="1" style="text-align: left;">Field Name</th>
			<th style="text-align: left;">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Request (<span style="color: rgb(169, 169, 169);">Optional</span>)</td>
			<td>
				<div>Request variable containing the request message to be sent over a HTTP to a remote target.</div>
				<ul>
					<li>By default, clearPayload is false.</li>
					<li>If clearPayload is set to true, the request payload is cleared after the request is sent to the HTTP target.</li>
					<li>Use the clearPayload option only if the request message is not required after the Service Callout is executed, because clearPayload allocates some memory during message processing.</li>
					<li>The policy fails to respond if the request message cannot be resolved by the element or is of an invalid request message type.</li>
				</ul>
			</td>
		</tr>
		<tr>
			<td>Response (<span style="color: rgb(169, 169, 169);">Optional</span>)</td>
			<td>
				<div>Output of the Service Callout assigned to the response variable.</div>
				<ul>
					<li>The output generated by the policy is assigned to the variable only when the entire response is read successfully by the policy. If the response message fails for any reason, the policy fails to respond.</li>
					<li>If this element is not specified, the policy execution does not wait for response to be completely read and executes the message flow steps.</li>
				</ul>
			</td>
		</tr>
		<tr>
			<td>HTTPTargetConnection</td>
			<td>Provides transport details such as URL, SSL, and load balancer. HTTPTarget.&nbsp;</td>
		</tr>
	</tbody>
</table>
<h2><a class="jumplink" name="schema"></a>Policy schema</h2>
<p>Each policy must conform to a policy schema. All policy constructs such as elements and attributes mentioned above are defined in a schema. To download the schema, <a href="/docs/download/file/fid/198">click here</a>.</p>
<h3>Example - Service Callout policy</h3>
<p>[gist:2628017]</p>
