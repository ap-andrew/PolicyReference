<p>[toc]</p>
<p>The API Platform supports a fault handling model that enables exceptions to be managed using policies.</p>

<h2>RaiseFault Policy</h2>
<p>The RaiseFault policy type works in a similar way as the AssignMessage policy type. A RaiseFault policy generates a custom response based on an exceptional condition along with any required HTTP headers, query parameters, or message content from the source message. </p>

<p>You can configure your API with a RaiseFault policy that executes when an event, defined as an exception, occurs in the message flow. When executed, the RaiseFault policy transfers the message flow execution to a default ErrorFlow, which in turn returns a fault response to the requesting client app.</p>

<h2>Policy FaultRules</h2>
<p>Fault handling is configured by defining a FaultRule and attaching policies to the FaultRule.</p>

<p>A FaultRule consists of:</p>
<ul>
	<li>An optional condition which classifies a fault based on category, subcategory, name and any additional attributes</li>
	<li>A set of policies that define fault handling behavior</li>
</ul>
<p>Any number of FaultRules can be defined on ProxyEndpoints and TargetEndpoints. When a fault occurs, only the first FaultRule whose condition evaluates to true is enforced.</p>
<p>FaultRules are evaluated in the following order:</p>
<p>Request Path:</p>
<ol>
	<li>Fault in ProxyRequest: FaultRules defined at ProxyEndpoint</li>
	<li>Fault in Routing: FaultRules defined at ProxyEndpoint</li>
	<li>Fault in TargetRequest: FaultRules defined at TargetEndpoint</li>
	<li>Fault in outbound request to target URL: FaultRules defined at TargetEndpoint</li>
</ol>
<p>Response Path:</p>
<ol>
	<li>Fault in TargetResponse: FaultRules defined at TargetEndpoint</li>
	<li>Fault in ProxyResponse: FaultRules defined at ProxyEndpoint</li>
	<li>Fault in returning response to ProxyEndpoint: FaultRules defined at ProxyEndpoint</li>
</ol>
<p>Policy attachments in a FaultRule are enforced in the order in which the policies are attached.</p>

<h2>Default Fault Handling</h2>

<p>Default fault handling can be specified at ProxyEndpoint and TargetEndpoint. Default fault handling always evaluates to true and is evaluated only where no other fault handling is defined. </p>

<p>When <code>enforceAlways</code> is set to <code>true</code>, policies are enforced even if fault handling has already been executed. This flag is provided to address use cases in which a ProxyEndpoint is required to perform some processing on all error responses, for example adding an HTTP header or modifying the response to obfuscate a backend target URL.
</p>
<p>If other FaultRules are defined, the default FaultRule is enforced only after those are evaluated and enforced only when <code>enforceAlways</code> flag is <code>true</code>.</p>

<p>The most common use case is returning a custom response message to the requesting app. </p>
<p>Custom error responses can be implemented by making templates available in, for example, <code>apiproxy/resources/messages</code>.) Under /messages <code>{fault_category}/{fault_sub_category}/{fault_name}/text_xml.template</code> <code>{fault_category}/{fault_sub_category}/{fault_name}/application_json.template</code> <code>{fault_category}/{fault_sub_category}/{fault_name}/text_html.template</code></p>
<p>Whenever the fault occurs, the system will have a default mechanism of generating error messages based on the fault. Templates can be defined at the category, sub-category or fault name level, enabling generic handling of faults by category.</p>
<p><code>{fault_category}/text_xml.template</code></p>
<p><code>{fault_category}/{fault_sub_category}/text_xml.template</code> <code>Content-Type</code> is set based on the HTTP request's <code>Accept</code> header.</p>
<p>The media type is converted into an identifier as: <code>text/xml</code> =&gt; <code>text_xml</code> <code>application/json</code> =&gt; <code>application_json</code></p>
<p>Localization is supported by adding the locale identifier as a suffix to the file name. The template is mapped based on the "Locale" HTTP header in the request. If locale can not be determined, the default locale is picked.</p>
<ul>
	<li><code>text_xml_en.template</code></li>
	<li><code>text_xml_fr.template</code></li>
	<li><code>text_xml.template (default locale)</code></li>
</ul>
<p>Within the template, contents can be customized by specifying variables in the form <code>{variable_name}</code>. The API Platform will substitute variable values as necessary before returning the response. The framework tries to first find the most specific error message (based on fault name). In the absence of such a template, the sub-category level messages are looked up and in the absence of which the category level messages are looked up.</p>

<h2>Sample RaiseFault policy</h2>
<p>Following policy, when attached will raise fault and the message flow shifts to error flow.</p>

	<pre>&lt;RaiseFault name="InvalidResponseCode" /&gt;</pre>

<p>After the policy execution the following flow variables will be available in the flow fault.name [value = InvalidResponseCode] fault.type [value = RaiseFault] fault.category [value = Messaging, Policy, Transport, System ] 

<p>The above variables can be used in the fault handling section to handle each fault differently. Also the fault can be handled with in the policy.</p>
<p>The error response is generated using constructs similar to those in the AssignMessage policy.</p>
<div id="well">
	<pre>&lt;RaiseFault name="ExceptionHandler"&gt;
 &lt;IgnoreUnresolvedVariables&gt;true&lt;/IgnoreUnresolvedVariables&gt;
 &lt;FaultResponse&gt;
   &lt;Copy&gt;
      &lt;Headers /&gt;
   &lt;/Copy&gt;
   &lt;Remove&gt;
      &lt;Headers&gt;
         &lt;Header name="h1"/&gt;
      &lt;/Headers&gt;
   &lt;/Remove&gt;
   &lt;Set&gt;
     &lt;Headers&gt;
       &lt;Header name="h1"&gt;hello {user}&lt;/Header&gt;
       &lt;Header name="h2"/&gt;bye {user}&lt;/Header&gt;
       &lt;Header name="h3.2"/&gt;bye {user}&lt;/Header&gt;
     &lt;/Headers&gt;
     &lt;Payload contentType="text/xml"&gt;
       &lt;root&gt;this is my payload {variable.v1}&lt;/root&gt;
     &lt;/Payload&gt;
     &lt;StatusCode&gt;{response.status.code} OR 500&lt;/StatusCode&gt;
     &lt;ReasonPhrase&gt;Server error&lt;/ReasonPhrase&gt;
   &lt;/Set&gt;
 &lt;FaultResponse&gt;
&lt;RaiseFault&gt;</pre>
</div>
<p>You can attach a list of policies to the defined RaiseFault policy for processing in the ErrorFlow. In cases where fault handling must be specific to the application, endpoint, or operations, you can define fault handling at the attachment points. For more information on the fault-handling mechanism, see [node:184].</p>
<h2><a class="jumplink" name="configure_policy"></a>Configuring a Raise Fault policy</h2>
<p>Configure the Raise Fault policy using the following elements.</p>
<table border="0" cellpadding="1" cellspacing="1" class="table" style="width: 690px;">
	<thead>
		<tr>
			<th style="text-align: left;">Field Name</th>
			<th style="text-align: left;">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>IgnoreUnresolvedVariables (<span style="color: rgb(169, 169, 169);">Optional</span>)</td>
			<td>
				<div>Ignores any unresolved variable error in the message flow.</div>
				<div>Valid values: true/false</div>
				<div>Default value: true</div>
			</td>
		</tr>
		<tr>
			<td>FaultResponse (<span style="color: rgb(169, 169, 169);">Optional</span>)</td>
			<td>Displays the fault response.</td>
		</tr>
	</tbody>
</table>
<h2><a class="jumplink" name="schema"></a>Policy schema</h2>
<p>Each policy must conform to a policy schema. All policy constructs such as elements and attributes mentioned above are defined in a schema. To download the schema, <a href="/docs/download/file/fid/192">click here</a>.</p>
<h3>Example - RaiseFault policy</h3>
<p>[gist:4347657]</p>
<h3>RaiseFault flow variables</h3>
<p>Flow variables play a pivotal role in message flow. These variables let advanced users customize the behavior of policies and flows, based on HTTP headers, message content, or Flow context. The following predefined Flow variables are available folllwoing RaiseFault policy execution. For more information about Flow variables, see [node:243].</p>
<table border="1" cellpadding="1" cellspacing="1" class="table" style="width: 690px;">
	<thead>
		<tr>
			<th style="text-align: left;">Variable</th>
			<th style="text-align: left;">Type</th>
			<th style="text-align: left;">Permission</th>
			<th style="text-align: left;">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>fault.name</td>
			<td>String</td>
			<td>Read-Only</td>
			<td>Returns the fault name in the error and if not available, an empty string.</td>
		</tr>
		<tr>
			<td>fault.type</td>
			<td>String</td>
			<td>Read-Only</td>
			<td>Returns the fault type in the error and if not available, an empty string.</td>
		</tr>
		<tr>
			<td>fault.category</td>
			<td>String</td>
			<td>Read-Only</td>
			<td>Returns the fault category in the error and if not available, an empty string.</td>
		</tr>
	</tbody>
</table>
<p><b>Note:</b> These variables are used in the fault handling flow to handle each fault differently.</p>
